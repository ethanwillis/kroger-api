{
  "_args": [
    [
      {
        "raw": "graphql-anywhere@^3.0.1",
        "scope": null,
        "escapedName": "graphql-anywhere",
        "name": "graphql-anywhere",
        "rawSpec": "^3.0.1",
        "spec": ">=3.0.1 <4.0.0",
        "type": "range"
      },
      "/home/ethan/programming/ethanwillis/kroger-api/node_modules/apollo-client"
    ]
  ],
  "_from": "graphql-anywhere@>=3.0.1 <4.0.0",
  "_id": "graphql-anywhere@3.0.1",
  "_inCache": true,
  "_location": "/graphql-anywhere",
  "_nodeVersion": "5.6.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/graphql-anywhere-3.0.1.tgz_1489638281758_0.9454973649699241"
  },
  "_npmUser": {
    "name": "helfer",
    "email": "helfer@meteor.com"
  },
  "_npmVersion": "3.6.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "graphql-anywhere@^3.0.1",
    "scope": null,
    "escapedName": "graphql-anywhere",
    "name": "graphql-anywhere",
    "rawSpec": "^3.0.1",
    "spec": ">=3.0.1 <4.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/apollo-client"
  ],
  "_resolved": "https://registry.npmjs.org/graphql-anywhere/-/graphql-anywhere-3.0.1.tgz",
  "_shasum": "73531db861174c8f212eafb9f8e84944b38b4e5a",
  "_shrinkwrap": null,
  "_spec": "graphql-anywhere@^3.0.1",
  "_where": "/home/ethan/programming/ethanwillis/kroger-api/node_modules/apollo-client",
  "author": {
    "name": "Sashko Stubailo",
    "email": "sashko@stubailo.com"
  },
  "bugs": {
    "url": "https://github.com/apollographql/graphql-anywhere/issues"
  },
  "dependencies": {},
  "description": "Run GraphQL queries with no schema and just one resolver",
  "devDependencies": {
    "@types/chai": "^3.4.34",
    "@types/graphql": "^0.8.0",
    "@types/isomorphic-fetch": "0.0.33",
    "@types/lodash": "^4.14.37",
    "@types/mocha": "^2.2.32",
    "@types/node": "^7.0.5",
    "@types/react": "^15.0.14",
    "@types/react-dom": "^0.14.18",
    "async": "^2.0.0",
    "chai": "^3.5.0",
    "chai-as-promised": "^6.0.0",
    "es6-promise": "^4.0.5",
    "graphql-tag": "^1.3.1",
    "grunt": "1.0.1",
    "grunt-tslint": "4.0.1",
    "isomorphic-fetch": "^2.2.1",
    "istanbul": "^0.4.5",
    "mocha": "^3.0.0",
    "react": "^15.3.1",
    "react-dom": "^15.3.1",
    "remap-istanbul": "^0.8.0",
    "source-map-support": "^0.4.0",
    "tslint": "^4.5.1",
    "typescript": "^2.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "73531db861174c8f212eafb9f8e84944b38b4e5a",
    "tarball": "https://registry.npmjs.org/graphql-anywhere/-/graphql-anywhere-3.0.1.tgz"
  },
  "gitHead": "67056f7c54ccfef54558bd8ee594e5b93f1d02bc",
  "homepage": "https://github.com/apollographql/graphql-anywhere#readme",
  "keywords": [
    "ecmascript",
    "es2015",
    "jsnext",
    "javascript",
    "relay",
    "npm",
    "react"
  ],
  "license": "MIT",
  "main": "./lib/src/index.js",
  "maintainers": [
    {
      "name": "helfer",
      "email": "helfer@meteor.com"
    },
    {
      "name": "mdg",
      "email": "npm@meteor.com"
    },
    {
      "name": "sashko",
      "email": "sashko@stubailo.com"
    },
    {
      "name": "tmeasday",
      "email": "tom@percolatestudio.com"
    }
  ],
  "name": "graphql-anywhere",
  "optionalDependencies": {},
  "readme": "# graphql-anywhere\n\n[![npm version](https://badge.fury.io/js/graphql-anywhere.svg)](https://badge.fury.io/js/graphql-anywhere)\n[![Build Status](https://travis-ci.org/apollographql/graphql-anywhere.svg?branch=master)](https://travis-ci.org/apollostack/graphql-anywhere)\n\nRun a GraphQL query anywhere, without a GraphQL server or a schema. Just pass in one resolver. Use it together with [graphql-tag](https://github.com/apollographql/graphql-tag).\n\n```\nnpm install graphql-anywhere graphql-tag\n```\n\nI think there are a lot of potentially exciting use cases for a completely standalone and schema-less GraphQL execution engine. We use it in [Apollo Client](https://github.com/apollostack/apollo-client) to read data from a Redux store with GraphQL.\n\nLet's come up with some more ideas - below are some use cases to get you started!\n\n## API\n\n```js\nimport graphql from 'graphql-anywhere'\n\ngraphql(resolver, document, rootValue?, context?, variables?, options?)\n```\n\n- `resolver`: A single resolver, called for every field on the query.\n    - Signature is: `(fieldName, rootValue, args, context, info) => any`\n- `document`: A GraphQL document, as generated by the template literal from `graphql-tag`\n- `rootValue`: The root value passed to the resolver when executing the root fields\n- `context`: A context object passed to the resolver for every field\n- `variables`: A dictionary of variables for the query\n- `options`: Options for execution\n\n#### Options\n\nThe last argument to the `graphql` function is a set of `graphql-anywhere`-specific options.\n\n- `resultMapper`: Transform field results after execution.\n    - Signature is: `(resultFields, resultRoot) => any`\n- `fragmentMatcher`: Decide whether to execute a fragment. Default is to always execute all fragments.\n    - Signature is: `(rootValue, typeCondition, context) => boolean`\n\n#### Resolver info\n\n`info`, the 5th argument to the resolver, is an object with supplementary information about execution. Send a PR or open an issue if you need additional information here.\n\n- `isLeaf`: A boolean that is `true` if this resolver is for a leaf field of the query, i.e. one that doesn't have a sub-selection.\n\n\n## Utilities\n\nSee http://dev.apollodata.com/react/fragments.html for examples of how you might use these.\n\n```js\nimport { filter } from 'graphql-anywhere'\n\nfilter(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data to be filtered by the `doc`\n\nFilter `data` according to `doc`.\n\n\n```js\nimport { check } from 'graphql-anywhere'\n\ncheck(doc, data);\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n- `data`: an object of data, as may have been filtered by `doc`.\n\nCheck that `data` is of the form defined by the query or fragment. Throw an exception if not.\n\n```js\nimport { propType } from 'graphql-anywhere'\n\nX.propTypes = {\n  foo: propType(doc),\n  bar: propType(doc).isRequired,\n}\n\n```\n\n- `doc`: a GraphQL document, as generated by the template literal from `graphql-tag`, typically either a query or a fragment.\n\nGenerate a React `propType` checking function to ensure that the passed prop is in the right form.\n\n### Supported GraphQL features\n\nWhy do you even need a library for this? Well, running a GraphQL query isn't as simple as just traversing the AST, since there are some pretty neat features that make the language a bit more complex to execute.\n\n- [x] Arguments\n- [x] Variables\n- [x] Aliases\n- [x] Fragments, both named and inline\n- [x] `@skip` and `@include` directives\n\nIf you come across a GraphQL feature not supported here, please file an issue.\n\n<a id=\"filter\"></a>\n## Example: Filter a nested object\n\n```js\nimport gql from 'graphql-tag';\nimport graphql from 'graphql-anywhere';\n\n// I don't need all this stuff!\nconst gitHubAPIResponse = {\n  \"url\": \"https://api.github.com/repos/octocat/Hello-World/issues/1347\",\n  \"title\": \"Found a bug\",\n  \"body\": \"I'm having a problem with this.\",\n  \"user\": {\n    \"login\": \"octocat\",\n    \"avatar_url\": \"https://github.com/images/error/octocat_happy.gif\",\n    \"url\": \"https://api.github.com/users/octocat\",\n  },\n  \"labels\": [\n    {\n      \"url\": \"https://api.github.com/repos/octocat/Hello-World/labels/bug\",\n      \"name\": \"bug\",\n      \"color\": \"f29513\"\n    }\n  ],\n};\n\n// Write a query that gets just the fields we want\nconst query = gql`\n  {\n    title\n    user {\n      login\n    }\n    labels {\n      name\n    }\n  }\n`;\n\n// Define a resolver that just returns a property\nconst resolver = (fieldName, root) => root[fieldName];\n\n// Filter the data!\nconst result = graphql(\n  resolver,\n  query,\n  gitHubAPIResponse\n);\n\nassert.deepEqual(result, {\n  \"title\": \"Found a bug\",\n  \"user\": {\n    \"login\": \"octocat\",\n  },\n  \"labels\": [\n    {\n      \"name\": \"bug\",\n    }\n  ],\n});\n```\n\n<a id=\"mock\"></a>\n## Example: Generate mock data\n\n```js\n// Write a query where the fields are types, but we alias them\nconst query = gql`\n  {\n    author {\n      name: string\n      age: int\n      address {\n        state: string\n      }\n    }\n  }\n`;\n\n// Define a resolver that uses the field name to determine the type\n// Note that we get the actual name, not the alias, but the alias\n// is used to determine the location in the response\nconst resolver = (fieldName) => ({\n  string: 'This is a string',\n  int: 5,\n}[fieldName] || 'continue');\n\n// Generate the object!\nconst result = graphql(\n  resolver,\n  query\n);\n\nassert.deepEqual(result, {\n  author: {\n    name: 'This is a string',\n    age: 5,\n    address: {\n      state: 'This is a string',\n    },\n  },\n});\n```\n<a id=\"normalizr\"></a>\n## Example: Read from a Redux store generated with Normalizr\n\n```js\nconst data = {\n  result: [1, 2],\n  entities: {\n    articles: {\n      1: { id: 1, title: 'Some Article', author: 1 },\n      2: { id: 2, title: 'Other Article', author: 1 },\n    },\n    users: {\n      1: { id: 1, name: 'Dan' },\n    },\n  },\n};\n\nconst query = gql`\n  {\n    result {\n      title\n      author {\n        name\n      }\n    }\n  }\n`;\n\nconst schema = {\n  articles: {\n    author: 'users',\n  },\n};\n\n// This resolver is a bit more complex than others, since it has to\n// correctly handle the root object, values by ID, and scalar leafs.\nconst resolver = (fieldName, rootValue, args, context): any => {\n  if (!rootValue) {\n    return context.result.map((id) => assign({}, context.entities.articles[id], {\n      __typename: 'articles',\n    }));\n  }\n\n  const typename = rootValue.__typename;\n  // If this field is a reference according to the schema\n  if (typename && schema[typename] && schema[typename][fieldName]) {\n    // Get the target type, and get it from entities by ID\n    const targetType: string = schema[typename][fieldName];\n    return assign({}, context.entities[targetType][rootValue[fieldName]], {\n      __typename: targetType,\n    });\n  }\n\n  // This field is just a scalar\n  return rootValue[fieldName];\n};\n\nconst result = graphql(\n  resolver,\n  query,\n  null,\n  data // pass data as context since we have to access it all the time\n);\n\n// This is the non-normalized data, with only the fields we asked for in our query!\nassert.deepEqual(result, {\n  result: [\n    {\n      title: 'Some Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n    {\n      title: 'Other Article',\n      author: {\n        name: 'Dan',\n      },\n    },\n  ],\n});\n```\n\n## Example: Generate React components\n\nYou can use the `resultMapper` option to convert your results into anything you like. In this case, we convert the result fields into children for a React component:\n\n```js\nconst resolver = (fieldName, root, args) => {\n  if (fieldName === 'text') {\n    return args.value;\n  }\n\n  return createElement(fieldName, args);\n};\n\nconst reactMapper = (childObj, root) => {\n  const reactChildren = Object.keys(childObj).map(key => childObj[key]);\n\n  if (root) {\n    return cloneElement(root, root.props, ...reactChildren);\n  }\n\n  return reactChildren[0];\n};\n\nfunction gqlToReact(query): any {\n  return graphql(\n    resolver,\n    query,\n    '',\n    null,\n    null,\n    { resultMapper: reactMapper },\n  );\n}\n\nconst query = gql`\n  {\n    div {\n      s1: span(id: \"my-id\") {\n        text(value: \"This is text\")\n      }\n      s2: span\n    }\n  }\n`;\n\nassert.equal(\n  renderToStaticMarkup(gqlToReact(query)),\n  '<div><span id=\"my-id\">This is text</span><span></span></div>'\n);\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/apollographql/graphql-anywhere.git"
  },
  "scripts": {
    "compile": "tsc",
    "coverage": "istanbul cover ./node_modules/mocha/bin/_mocha -- --reporter dot --full-trace lib/test/tests.js",
    "lint": "grunt tslint",
    "postcoverage": "remap-istanbul --input coverage/coverage.json --type lcovonly --output coverage/lcov.info",
    "posttest": "npm run lint",
    "prepublish": "npm run compile",
    "pretest": "npm run compile",
    "test": "npm run testonly --",
    "testonly": "mocha --reporter spec --full-trace lib/test/tests.js",
    "watch": "tsc -w"
  },
  "typings": "./lib/src/index.d.ts",
  "version": "3.0.1"
}
